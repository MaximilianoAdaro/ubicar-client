/* tslint:disable */
/* eslint-disable */
/**
 * Api Documentation
 * Api Documentation
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   *
   * @type {string}
   * @memberof Address
   */
  department: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Address
   */
  number: number;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  postalCode: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  street: string;
  /**
   *
   * @type {Town}
   * @memberof Address
   */
  town: Town;
}
/**
 *
 * @export
 * @interface AddressDTO
 */
export interface AddressDTO {
  /**
   *
   * @type {string}
   * @memberof AddressDTO
   */
  department: string;
  /**
   *
   * @type {number}
   * @memberof AddressDTO
   */
  number?: number;
  /**
   *
   * @type {string}
   * @memberof AddressDTO
   */
  postalCode: string;
  /**
   *
   * @type {string}
   * @memberof AddressDTO
   */
  street: string;
  /**
   *
   * @type {string}
   * @memberof AddressDTO
   */
  town_id: string;
}
/**
 *
 * @export
 * @interface Amenity
 */
export interface Amenity {
  /**
   *
   * @type {string}
   * @memberof Amenity
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Amenity
   */
  label: string;
  /**
   *
   * @type {Array<Property>}
   * @memberof Amenity
   */
  properties: Array<Property>;
}
/**
 *
 * @export
 * @interface AmenityDTO
 */
export interface AmenityDTO {
  /**
   *
   * @type {string}
   * @memberof AmenityDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof AmenityDTO
   */
  label: string;
}
/**
 *
 * @export
 * @interface City
 */
export interface City {
  /**
   *
   * @type {string}
   * @memberof City
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof City
   */
  name: string;
  /**
   *
   * @type {State}
   * @memberof City
   */
  state: State;
}
/**
 *
 * @export
 * @interface CityDTO
 */
export interface CityDTO {
  /**
   *
   * @type {string}
   * @memberof CityDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CityDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface ConstructionMaterial
 */
export interface ConstructionMaterial {
  /**
   *
   * @type {string}
   * @memberof ConstructionMaterial
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ConstructionMaterial
   */
  label: string;
  /**
   *
   * @type {Array<Property>}
   * @memberof ConstructionMaterial
   */
  properties: Array<Property>;
}
/**
 *
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  label: string;
}
/**
 *
 * @export
 * @interface ContactDto
 */
export interface ContactDto {
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  label: string;
}
/**
 *
 * @export
 * @interface Country
 */
export interface Country {
  /**
   *
   * @type {string}
   * @memberof Country
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Country
   */
  name: string;
}
/**
 *
 * @export
 * @interface CreatePropertyDTO
 */
export interface CreatePropertyDTO {
  /**
   *
   * @type {AddressDTO}
   * @memberof CreatePropertyDTO
   */
  address: AddressDTO;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatePropertyDTO
   */
  amenities: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  comments: string;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  condition: string;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  constructionDate?: number;
  /**
   *
   * @type {Array<ContactDto>}
   * @memberof CreatePropertyDTO
   */
  contacts: Array<ContactDto>;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  coveredSquareFoot?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  environments?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  expenses?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  fullBaths?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  levels?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatePropertyDTO
   */
  links: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatePropertyDTO
   */
  materials: Array<string>;
  /**
   *
   * @type {Array<OpenHouseDateDto>}
   * @memberof CreatePropertyDTO
   */
  openHouse: Array<OpenHouseDateDto>;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  parkDescription: string;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  price?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  rooms?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatePropertyDTO
   */
  security: Array<string>;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  squareFoot?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  style: string;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof CreatePropertyDTO
   */
  toilets?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyDTO
   */
  type: string;
}
/**
 *
 * @export
 * @interface GoogleLoginUserDTO
 */
export interface GoogleLoginUserDTO {
  /**
   *
   * @type {string}
   * @memberof GoogleLoginUserDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof GoogleLoginUserDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  hour?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  minute?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  nano?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  second?: number;
}
/**
 *
 * @export
 * @interface LocalTimeReq
 */
export interface LocalTimeReq {
  /**
   *
   * @type {string}
   * @memberof LocalTimeReq
   */
  hour?: string;
  /**
   *
   * @type {string}
   * @memberof LocalTimeReq
   */
  minute?: string;
  /**
   *
   * @type {number}
   * @memberof LocalTimeReq
   */
  nano?: number;
  /**
   *
   * @type {string}
   * @memberof LocalTimeReq
   */
  second?: string;
}
/**
 *
 * @export
 * @interface LocalTimeRes
 */
export interface LocalTimeRes {
  /**
   *
   * @type {number}
   * @memberof LocalTimeRes
   */
  hour?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTimeRes
   */
  minute?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTimeRes
   */
  nano?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTimeRes
   */
  second?: number;
}
/**
 *
 * @export
 * @interface LogInUserDTO
 */
export interface LogInUserDTO {
  /**
   *
   * @type {string}
   * @memberof LogInUserDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LogInUserDTO
   */
  password: string;
}
/**
 *
 * @export
 * @interface MaterialDTO
 */
export interface MaterialDTO {
  /**
   *
   * @type {string}
   * @memberof MaterialDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MaterialDTO
   */
  label: string;
}
/**
 *
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
  /**
   *
   * @type {boolean}
   * @memberof ModelAndView
   */
  empty?: boolean;
  /**
   *
   * @type {object}
   * @memberof ModelAndView
   */
  model?: object;
  /**
   *
   * @type {{ [key: string]: object | undefined; }}
   * @memberof ModelAndView
   */
  modelMap?: { [key: string]: object | undefined };
  /**
   *
   * @type {boolean}
   * @memberof ModelAndView
   */
  reference?: boolean;
  /**
   *
   * @type {string}
   * @memberof ModelAndView
   */
  status?: ModelAndViewStatusEnum;
  /**
   *
   * @type {View}
   * @memberof ModelAndView
   */
  view?: View;
  /**
   *
   * @type {string}
   * @memberof ModelAndView
   */
  viewName?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ModelAndViewStatusEnum {
  Accepted = "ACCEPTED",
  AlreadyReported = "ALREADY_REPORTED",
  BadGateway = "BAD_GATEWAY",
  BadRequest = "BAD_REQUEST",
  BandwidthLimitExceeded = "BANDWIDTH_LIMIT_EXCEEDED",
  Checkpoint = "CHECKPOINT",
  Conflict = "CONFLICT",
  Continue = "CONTINUE",
  Created = "CREATED",
  DestinationLocked = "DESTINATION_LOCKED",
  ExpectationFailed = "EXPECTATION_FAILED",
  FailedDependency = "FAILED_DEPENDENCY",
  Forbidden = "FORBIDDEN",
  Found = "FOUND",
  GatewayTimeout = "GATEWAY_TIMEOUT",
  Gone = "GONE",
  HttpVersionNotSupported = "HTTP_VERSION_NOT_SUPPORTED",
  ImUsed = "IM_USED",
  InsufficientSpaceOnResource = "INSUFFICIENT_SPACE_ON_RESOURCE",
  InsufficientStorage = "INSUFFICIENT_STORAGE",
  InternalServerError = "INTERNAL_SERVER_ERROR",
  IAmATeapot = "I_AM_A_TEAPOT",
  LengthRequired = "LENGTH_REQUIRED",
  Locked = "LOCKED",
  LoopDetected = "LOOP_DETECTED",
  MethodFailure = "METHOD_FAILURE",
  MethodNotAllowed = "METHOD_NOT_ALLOWED",
  MovedPermanently = "MOVED_PERMANENTLY",
  MovedTemporarily = "MOVED_TEMPORARILY",
  MultipleChoices = "MULTIPLE_CHOICES",
  MultiStatus = "MULTI_STATUS",
  NetworkAuthenticationRequired = "NETWORK_AUTHENTICATION_REQUIRED",
  NonAuthoritativeInformation = "NON_AUTHORITATIVE_INFORMATION",
  NotAcceptable = "NOT_ACCEPTABLE",
  NotExtended = "NOT_EXTENDED",
  NotFound = "NOT_FOUND",
  NotImplemented = "NOT_IMPLEMENTED",
  NotModified = "NOT_MODIFIED",
  NoContent = "NO_CONTENT",
  Ok = "OK",
  PartialContent = "PARTIAL_CONTENT",
  PayloadTooLarge = "PAYLOAD_TOO_LARGE",
  PaymentRequired = "PAYMENT_REQUIRED",
  PermanentRedirect = "PERMANENT_REDIRECT",
  PreconditionFailed = "PRECONDITION_FAILED",
  PreconditionRequired = "PRECONDITION_REQUIRED",
  Processing = "PROCESSING",
  ProxyAuthenticationRequired = "PROXY_AUTHENTICATION_REQUIRED",
  RequestedRangeNotSatisfiable = "REQUESTED_RANGE_NOT_SATISFIABLE",
  RequestEntityTooLarge = "REQUEST_ENTITY_TOO_LARGE",
  RequestHeaderFieldsTooLarge = "REQUEST_HEADER_FIELDS_TOO_LARGE",
  RequestTimeout = "REQUEST_TIMEOUT",
  RequestUriTooLong = "REQUEST_URI_TOO_LONG",
  ResetContent = "RESET_CONTENT",
  SeeOther = "SEE_OTHER",
  ServiceUnavailable = "SERVICE_UNAVAILABLE",
  SwitchingProtocols = "SWITCHING_PROTOCOLS",
  TemporaryRedirect = "TEMPORARY_REDIRECT",
  TooEarly = "TOO_EARLY",
  TooManyRequests = "TOO_MANY_REQUESTS",
  Unauthorized = "UNAUTHORIZED",
  UnavailableForLegalReasons = "UNAVAILABLE_FOR_LEGAL_REASONS",
  UnprocessableEntity = "UNPROCESSABLE_ENTITY",
  UnsupportedMediaType = "UNSUPPORTED_MEDIA_TYPE",
  UpgradeRequired = "UPGRADE_REQUIRED",
  UriTooLong = "URI_TOO_LONG",
  UseProxy = "USE_PROXY",
  VariantAlsoNegotiates = "VARIANT_ALSO_NEGOTIATES",
}

/**
 *
 * @export
 * @interface OpenHouseDate
 */
export interface OpenHouseDate {
  /**
   *
   * @type {string}
   * @memberof OpenHouseDate
   */
  day: string;
  /**
   *
   * @type {LocalTime}
   * @memberof OpenHouseDate
   */
  finalTime: LocalTime;
  /**
   *
   * @type {string}
   * @memberof OpenHouseDate
   */
  id: string;
  /**
   *
   * @type {LocalTime}
   * @memberof OpenHouseDate
   */
  initialTime: LocalTime;
}
/**
 *
 * @export
 * @interface OpenHouseDateDto
 */
export interface OpenHouseDateDto {
  /**
   *
   * @type {string}
   * @memberof OpenHouseDateDto
   */
  day: string;
  /**
   *
   * @type {LocalTimeReq}
   * @memberof OpenHouseDateDto
   */
  finalTime: LocalTimeReq;
  /**
   *
   * @type {LocalTimeReq}
   * @memberof OpenHouseDateDto
   */
  initialTime: LocalTimeReq;
}
/**
 *
 * @export
 * @interface PagePropertyPreviewDTO
 */
export interface PagePropertyPreviewDTO {
  /**
   *
   * @type {Array<PropertyPreviewDTO>}
   * @memberof PagePropertyPreviewDTO
   */
  content?: Array<PropertyPreviewDTO>;
  /**
   *
   * @type {boolean}
   * @memberof PagePropertyPreviewDTO
   */
  empty?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PagePropertyPreviewDTO
   */
  first?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PagePropertyPreviewDTO
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PagePropertyPreviewDTO
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PagePropertyPreviewDTO
   */
  numberOfElements?: number;
  /**
   *
   * @type {Pageable}
   * @memberof PagePropertyPreviewDTO
   */
  pageable?: Pageable;
  /**
   *
   * @type {number}
   * @memberof PagePropertyPreviewDTO
   */
  size?: number;
  /**
   *
   * @type {Sort}
   * @memberof PagePropertyPreviewDTO
   */
  sort?: Sort;
  /**
   *
   * @type {number}
   * @memberof PagePropertyPreviewDTO
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PagePropertyPreviewDTO
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  offset?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageNumber?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageSize?: number;
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  paged?: boolean;
  /**
   *
   * @type {Sort}
   * @memberof Pageable
   */
  sort?: Sort;
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  unpaged?: boolean;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {boolean}
   * @memberof Permission
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  creationDate: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  title: string;
  /**
   *
   * @type {Array<UserRole>}
   * @memberof Permission
   */
  userRoles: Array<UserRole>;
}
/**
 *
 * @export
 * @interface Property
 */
export interface Property {
  /**
   *
   * @type {Address}
   * @memberof Property
   */
  address: Address;
  /**
   *
   * @type {Array<Amenity>}
   * @memberof Property
   */
  amenities: Array<Amenity>;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  comments: string;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  condition: PropertyConditionEnum;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  constructionDate: number;
  /**
   *
   * @type {Array<Contact>}
   * @memberof Property
   */
  contacts: Array<Contact>;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  coveredSquareFoot: number;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  environments: number;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  expenses: number;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  fullBaths: number;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  levels: number;
  /**
   *
   * @type {Array<User>}
   * @memberof Property
   */
  likes: Array<User>;
  /**
   *
   * @type {Array<string>}
   * @memberof Property
   */
  links: Array<string>;
  /**
   *
   * @type {Array<ConstructionMaterial>}
   * @memberof Property
   */
  materials: Array<ConstructionMaterial>;
  /**
   *
   * @type {Array<OpenHouseDate>}
   * @memberof Property
   */
  openHouse: Array<OpenHouseDate>;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  parkDescription: string;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  price: number;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  rooms: number;
  /**
   *
   * @type {Array<SecurityMeasure>}
   * @memberof Property
   */
  security: Array<SecurityMeasure>;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  squareFoot: number;
  /**
   *
   * @type {Style}
   * @memberof Property
   */
  style: Style;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof Property
   */
  toilets: number;
  /**
   *
   * @type {string}
   * @memberof Property
   */
  type: PropertyTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PropertyConditionEnum {
  Rent = "RENT",
  Sale = "SALE",
}
/**
 * @export
 * @enum {string}
 */
export enum PropertyTypeEnum {
  Casa = "Casa",
  Cochera = "Cochera",
  Compartido = "Compartido",
  Consultorio = "Consultorio",
  Country = "Country",
  Departamento = "Departamento",
  Edificio = "Edificio",
  Flat = "Flat",
  Galpon = "Galpon",
  Hotel = "Hotel",
  Local = "Local",
  Loft = "Loft",
  Oficina = "Oficina",
  Ph = "PH",
  Quinta = "Quinta",
  Terreno = "Terreno",
}

/**
 *
 * @export
 * @interface PropertyDTO
 */
export interface PropertyDTO {
  /**
   *
   * @type {Address}
   * @memberof PropertyDTO
   */
  address: Address;
  /**
   *
   * @type {Array<Amenity>}
   * @memberof PropertyDTO
   */
  amenities: Array<Amenity>;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  comments: string;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  condition: PropertyDTOConditionEnum;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  constructionDate: number;
  /**
   *
   * @type {Array<Contact>}
   * @memberof PropertyDTO
   */
  contacts: Array<Contact>;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  coveredSquareFoot: number;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  environments: number;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  expenses: number;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  fullBaths: number;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  levels: number;
  /**
   *
   * @type {Array<string>}
   * @memberof PropertyDTO
   */
  links: Array<string>;
  /**
   *
   * @type {Array<ConstructionMaterial>}
   * @memberof PropertyDTO
   */
  materials: Array<ConstructionMaterial>;
  /**
   *
   * @type {Array<OpenHouseDate>}
   * @memberof PropertyDTO
   */
  openHouse: Array<OpenHouseDate>;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  parkDescription: string;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  price: number;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  rooms: number;
  /**
   *
   * @type {Array<SecurityMeasure>}
   * @memberof PropertyDTO
   */
  security: Array<SecurityMeasure>;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  squareFoot: number;
  /**
   *
   * @type {Style}
   * @memberof PropertyDTO
   */
  style: Style;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof PropertyDTO
   */
  toilets: number;
  /**
   *
   * @type {string}
   * @memberof PropertyDTO
   */
  type: PropertyDTOTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PropertyDTOConditionEnum {
  Rent = "RENT",
  Sale = "SALE",
}
/**
 * @export
 * @enum {string}
 */
export enum PropertyDTOTypeEnum {
  Casa = "Casa",
  Cochera = "Cochera",
  Compartido = "Compartido",
  Consultorio = "Consultorio",
  Country = "Country",
  Departamento = "Departamento",
  Edificio = "Edificio",
  Flat = "Flat",
  Galpon = "Galpon",
  Hotel = "Hotel",
  Local = "Local",
  Loft = "Loft",
  Oficina = "Oficina",
  Ph = "PH",
  Quinta = "Quinta",
  Terreno = "Terreno",
}

/**
 *
 * @export
 * @interface PropertyPreviewDTO
 */
export interface PropertyPreviewDTO {
  /**
   *
   * @type {Address}
   * @memberof PropertyPreviewDTO
   */
  address: Address;
  /**
   *
   * @type {string}
   * @memberof PropertyPreviewDTO
   */
  condition: PropertyPreviewDTOConditionEnum;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  coveredSquareFoot: number;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  fullBaths: number;
  /**
   *
   * @type {string}
   * @memberof PropertyPreviewDTO
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  price: number;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  rooms: number;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  squareFoot: number;
  /**
   *
   * @type {string}
   * @memberof PropertyPreviewDTO
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof PropertyPreviewDTO
   */
  toilets: number;
  /**
   *
   * @type {string}
   * @memberof PropertyPreviewDTO
   */
  type: PropertyPreviewDTOTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PropertyPreviewDTOConditionEnum {
  Rent = "RENT",
  Sale = "SALE",
}
/**
 * @export
 * @enum {string}
 */
export enum PropertyPreviewDTOTypeEnum {
  Casa = "Casa",
  Cochera = "Cochera",
  Compartido = "Compartido",
  Consultorio = "Consultorio",
  Country = "Country",
  Departamento = "Departamento",
  Edificio = "Edificio",
  Flat = "Flat",
  Galpon = "Galpon",
  Hotel = "Hotel",
  Local = "Local",
  Loft = "Loft",
  Oficina = "Oficina",
  Ph = "PH",
  Quinta = "Quinta",
  Terreno = "Terreno",
}

/**
 *
 * @export
 * @interface RoleDTO
 */
export interface RoleDTO {
  /**
   *
   * @type {string}
   * @memberof RoleDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof RoleDTO
   */
  title: string;
}
/**
 *
 * @export
 * @interface SecurityDTO
 */
export interface SecurityDTO {
  /**
   *
   * @type {string}
   * @memberof SecurityDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SecurityDTO
   */
  label: string;
}
/**
 *
 * @export
 * @interface SecurityMeasure
 */
export interface SecurityMeasure {
  /**
   *
   * @type {string}
   * @memberof SecurityMeasure
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SecurityMeasure
   */
  label: string;
  /**
   *
   * @type {Array<Property>}
   * @memberof SecurityMeasure
   */
  properties: Array<Property>;
}
/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  empty?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  sorted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  unsorted?: boolean;
}
/**
 *
 * @export
 * @interface State
 */
export interface State {
  /**
   *
   * @type {Country}
   * @memberof State
   */
  country: Country;
  /**
   *
   * @type {string}
   * @memberof State
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof State
   */
  name: string;
}
/**
 *
 * @export
 * @interface StateDTO
 */
export interface StateDTO {
  /**
   *
   * @type {string}
   * @memberof StateDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof StateDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface Style
 */
export interface Style {
  /**
   *
   * @type {string}
   * @memberof Style
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Style
   */
  label: string;
}
/**
 *
 * @export
 * @interface StyleDTO
 */
export interface StyleDTO {
  /**
   *
   * @type {string}
   * @memberof StyleDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof StyleDTO
   */
  label: string;
}
/**
 *
 * @export
 * @interface Town
 */
export interface Town {
  /**
   *
   * @type {City}
   * @memberof Town
   */
  city: City;
  /**
   *
   * @type {string}
   * @memberof Town
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Town
   */
  name: string;
}
/**
 *
 * @export
 * @interface TownDTO
 */
export interface TownDTO {
  /**
   *
   * @type {string}
   * @memberof TownDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TownDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {Array<Property>}
   * @memberof User
   */
  likedProperties: Array<Property>;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  userName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  userOrigin: UserUserOriginEnum;
  /**
   *
   * @type {UserRole}
   * @memberof User
   */
  userRole: UserRole;
}

/**
 * @export
 * @enum {string}
 */
export enum UserUserOriginEnum {
  Google = "GOOGLE",
  Ubicar = "UBICAR",
}

/**
 *
 * @export
 * @interface UserCreationDTO
 */
export interface UserCreationDTO {
  /**
   *
   * @type {string}
   * @memberof UserCreationDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserCreationDTO
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreationDTO
   */
  userName: string;
  /**
   *
   * @type {string}
   * @memberof UserCreationDTO
   */
  userRole: string;
}
/**
 *
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  userName: string;
}
/**
 *
 * @export
 * @interface UserRole
 */
export interface UserRole {
  /**
   *
   * @type {boolean}
   * @memberof UserRole
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  creationDate: string;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  id: string;
  /**
   *
   * @type {Array<Permission>}
   * @memberof UserRole
   */
  permissions: Array<Permission>;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  title: string;
}
/**
 *
 * @export
 * @interface View
 */
export interface View {
  /**
   *
   * @type {string}
   * @memberof View
   */
  contentType?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary getLogged
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary logOut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logOutUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary login
     * @param {LogInUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUsingPOST: async (
      logInUser: LogInUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'logInUser' is not null or undefined
      assertParamExists("loginUsingPOST", "logInUser", logInUser);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logInUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary loginWithGoogle
     * @param {string} authorization Authorization
     * @param {GoogleLoginUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginWithGoogleUsingPOST: async (
      authorization: string,
      logInUser: GoogleLoginUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "loginWithGoogleUsingPOST",
        "authorization",
        authorization
      );
      // verify required parameter 'logInUser' is not null or undefined
      assertParamExists("loginWithGoogleUsingPOST", "logInUser", logInUser);
      const localVarPath = `/auth/google-login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logInUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary register
     * @param {UserCreationDTO} userCreation userCreation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUsingPOST: async (
      userCreation: UserCreationDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreation' is not null or undefined
      assertParamExists("registerUsingPOST", "userCreation", userCreation);
      const localVarPath = `/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getLogged
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoggedUsingGET(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLoggedUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolesUsingGET(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRolesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary logOut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logOutUsingPOST(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logOutUsingPOST(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary login
     * @param {LogInUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUsingPOST(
      logInUser: LogInUserDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginUsingPOST(
        logInUser,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary loginWithGoogle
     * @param {string} authorization Authorization
     * @param {GoogleLoginUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginWithGoogleUsingPOST(
      authorization: string,
      logInUser: GoogleLoginUserDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.loginWithGoogleUsingPOST(
          authorization,
          logInUser,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary register
     * @param {UserCreationDTO} userCreation userCreation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUsingPOST(
      userCreation: UserCreationDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.registerUsingPOST(
          userCreation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthControllerApiFp(configuration);
  return {
    /**
     *
     * @summary getLogged
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedUsingGET(options?: any): AxiosPromise<UserDTO> {
      return localVarFp
        .getLoggedUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesUsingGET(options?: any): AxiosPromise<Array<RoleDTO>> {
      return localVarFp
        .getRolesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary logOut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logOutUsingPOST(options?: any): AxiosPromise<object> {
      return localVarFp
        .logOutUsingPOST(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary login
     * @param {LogInUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUsingPOST(
      logInUser: LogInUserDTO,
      options?: any
    ): AxiosPromise<UserDTO> {
      return localVarFp
        .loginUsingPOST(logInUser, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary loginWithGoogle
     * @param {string} authorization Authorization
     * @param {GoogleLoginUserDTO} logInUser logInUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginWithGoogleUsingPOST(
      authorization: string,
      logInUser: GoogleLoginUserDTO,
      options?: any
    ): AxiosPromise<UserDTO> {
      return localVarFp
        .loginWithGoogleUsingPOST(authorization, logInUser, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary register
     * @param {UserCreationDTO} userCreation userCreation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUsingPOST(
      userCreation: UserCreationDTO,
      options?: any
    ): AxiosPromise<UserDTO> {
      return localVarFp
        .registerUsingPOST(userCreation, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthControllerApi - interface
 * @export
 * @interface AuthControllerApi
 */
export interface AuthControllerApiInterface {
  /**
   *
   * @summary getLogged
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  getLoggedUsingGET(options?: any): AxiosPromise<UserDTO>;

  /**
   *
   * @summary getRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  getRolesUsingGET(options?: any): AxiosPromise<Array<RoleDTO>>;

  /**
   *
   * @summary logOut
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  logOutUsingPOST(options?: any): AxiosPromise<object>;

  /**
   *
   * @summary login
   * @param {LogInUserDTO} logInUser logInUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  loginUsingPOST(logInUser: LogInUserDTO, options?: any): AxiosPromise<UserDTO>;

  /**
   *
   * @summary loginWithGoogle
   * @param {string} authorization Authorization
   * @param {GoogleLoginUserDTO} logInUser logInUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  loginWithGoogleUsingPOST(
    authorization: string,
    logInUser: GoogleLoginUserDTO,
    options?: any
  ): AxiosPromise<UserDTO>;

  /**
   *
   * @summary register
   * @param {UserCreationDTO} userCreation userCreation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApiInterface
   */
  registerUsingPOST(
    userCreation: UserCreationDTO,
    options?: any
  ): AxiosPromise<UserDTO>;
}

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi
  extends BaseAPI
  implements AuthControllerApiInterface
{
  /**
   *
   * @summary getLogged
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public getLoggedUsingGET(options?: any) {
    return AuthControllerApiFp(this.configuration)
      .getLoggedUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public getRolesUsingGET(options?: any) {
    return AuthControllerApiFp(this.configuration)
      .getRolesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary logOut
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public logOutUsingPOST(options?: any) {
    return AuthControllerApiFp(this.configuration)
      .logOutUsingPOST(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary login
   * @param {LogInUserDTO} logInUser logInUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public loginUsingPOST(logInUser: LogInUserDTO, options?: any) {
    return AuthControllerApiFp(this.configuration)
      .loginUsingPOST(logInUser, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary loginWithGoogle
   * @param {string} authorization Authorization
   * @param {GoogleLoginUserDTO} logInUser logInUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public loginWithGoogleUsingPOST(
    authorization: string,
    logInUser: GoogleLoginUserDTO,
    options?: any
  ) {
    return AuthControllerApiFp(this.configuration)
      .loginWithGoogleUsingPOST(authorization, logInUser, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary register
   * @param {UserCreationDTO} userCreation userCreation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public registerUsingPOST(userCreation: UserCreationDTO, options?: any) {
    return AuthControllerApiFp(this.configuration)
      .registerUsingPOST(userCreation, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingDELETE: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingHEAD: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "HEAD",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingOPTIONS: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "OPTIONS",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPATCH: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPUT: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    BasicErrorControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingDELETE(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.errorUsingDELETE(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingGET(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingHEAD(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingHEAD(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingOPTIONS(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.errorUsingOPTIONS(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingPATCH(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPATCH(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingPOST(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPOST(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async errorUsingPUT(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPUT(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BasicErrorControllerApiFp(configuration);
  return {
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingDELETE(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingDELETE(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingGET(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingHEAD(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingHEAD(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingOPTIONS(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingOPTIONS(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPATCH(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingPATCH(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPOST(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingPOST(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    errorUsingPUT(
      options?: any
    ): AxiosPromise<{ [key: string]: object | undefined }> {
      return localVarFp
        .errorUsingPUT(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BasicErrorControllerApi - interface
 * @export
 * @interface BasicErrorControllerApi
 */
export interface BasicErrorControllerApiInterface {
  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingDELETE(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingGET(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingHEAD(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingOPTIONS(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingPATCH(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingPOST(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApiInterface
   */
  errorUsingPUT(
    options?: any
  ): AxiosPromise<{ [key: string]: object | undefined }>;
}

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi
  extends BaseAPI
  implements BasicErrorControllerApiInterface
{
  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingDELETE(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingDELETE(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingGET(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingHEAD(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingHEAD(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingOPTIONS(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingOPTIONS(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingPATCH(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingPATCH(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingPOST(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingPOST(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary error
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BasicErrorControllerApi
   */
  public errorUsingPUT(options?: any) {
    return BasicErrorControllerApiFp(this.configuration)
      .errorUsingPUT(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LocationControllerApi - axios parameter creator
 * @export
 */
export const LocationControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary getCities
     * @param {string} stateId stateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCitiesUsingGET: async (
      stateId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      assertParamExists("getCitiesUsingGET", "stateId", stateId);
      const localVarPath = `/cities/{stateId}`.replace(
        `{${"stateId"}}`,
        encodeURIComponent(String(stateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getStates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/states`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getTowns
     * @param {string} cityId cityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTownsUsingGET: async (
      cityId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cityId' is not null or undefined
      assertParamExists("getTownsUsingGET", "cityId", cityId);
      const localVarPath = `/towns/{cityId}`.replace(
        `{${"cityId"}}`,
        encodeURIComponent(String(cityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LocationControllerApi - functional programming interface
 * @export
 */
export const LocationControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    LocationControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getCities
     * @param {string} stateId stateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCitiesUsingGET(
      stateId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CityDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCitiesUsingGET(stateId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getStates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatesUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StateDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStatesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getTowns
     * @param {string} cityId cityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTownsUsingGET(
      cityId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TownDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTownsUsingGET(cityId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LocationControllerApi - factory interface
 * @export
 */
export const LocationControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LocationControllerApiFp(configuration);
  return {
    /**
     *
     * @summary getCities
     * @param {string} stateId stateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCitiesUsingGET(
      stateId: string,
      options?: any
    ): AxiosPromise<Array<CityDTO>> {
      return localVarFp
        .getCitiesUsingGET(stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getStates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatesUsingGET(options?: any): AxiosPromise<Array<StateDTO>> {
      return localVarFp
        .getStatesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getTowns
     * @param {string} cityId cityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTownsUsingGET(
      cityId: string,
      options?: any
    ): AxiosPromise<Array<TownDTO>> {
      return localVarFp
        .getTownsUsingGET(cityId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LocationControllerApi - interface
 * @export
 * @interface LocationControllerApi
 */
export interface LocationControllerApiInterface {
  /**
   *
   * @summary getCities
   * @param {string} stateId stateId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApiInterface
   */
  getCitiesUsingGET(
    stateId: string,
    options?: any
  ): AxiosPromise<Array<CityDTO>>;

  /**
   *
   * @summary getStates
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApiInterface
   */
  getStatesUsingGET(options?: any): AxiosPromise<Array<StateDTO>>;

  /**
   *
   * @summary getTowns
   * @param {string} cityId cityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApiInterface
   */
  getTownsUsingGET(cityId: string, options?: any): AxiosPromise<Array<TownDTO>>;
}

/**
 * LocationControllerApi - object-oriented interface
 * @export
 * @class LocationControllerApi
 * @extends {BaseAPI}
 */
export class LocationControllerApi
  extends BaseAPI
  implements LocationControllerApiInterface
{
  /**
   *
   * @summary getCities
   * @param {string} stateId stateId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApi
   */
  public getCitiesUsingGET(stateId: string, options?: any) {
    return LocationControllerApiFp(this.configuration)
      .getCitiesUsingGET(stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getStates
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApi
   */
  public getStatesUsingGET(options?: any) {
    return LocationControllerApiFp(this.configuration)
      .getStatesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getTowns
   * @param {string} cityId cityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationControllerApi
   */
  public getTownsUsingGET(cityId: string, options?: any) {
    return LocationControllerApiFp(this.configuration)
      .getTownsUsingGET(cityId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OptionalsControllerApi - axios parameter creator
 * @export
 */
export const OptionalsControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary getAmenities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAmenitiesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/amenities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getMaterials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMaterialsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/materials`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getSecurities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecuritiesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/securities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getStyles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStylesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/styles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesUsingGET: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OptionalsControllerApi - functional programming interface
 * @export
 */
export const OptionalsControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    OptionalsControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getAmenities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAmenitiesUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AmenityDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAmenitiesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getMaterials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMaterialsUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MaterialDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMaterialsUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getSecurities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSecuritiesUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SecurityDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSecuritiesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getStyles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStylesUsingGET(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StyleDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStylesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTypesUsingGET(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTypesUsingGET(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * OptionalsControllerApi - factory interface
 * @export
 */
export const OptionalsControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OptionalsControllerApiFp(configuration);
  return {
    /**
     *
     * @summary getAmenities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAmenitiesUsingGET(options?: any): AxiosPromise<Array<AmenityDTO>> {
      return localVarFp
        .getAmenitiesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getMaterials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMaterialsUsingGET(options?: any): AxiosPromise<Array<MaterialDTO>> {
      return localVarFp
        .getMaterialsUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getSecurities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecuritiesUsingGET(options?: any): AxiosPromise<Array<SecurityDTO>> {
      return localVarFp
        .getSecuritiesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getStyles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStylesUsingGET(options?: any): AxiosPromise<Array<StyleDTO>> {
      return localVarFp
        .getStylesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesUsingGET(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getTypesUsingGET(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OptionalsControllerApi - interface
 * @export
 * @interface OptionalsControllerApi
 */
export interface OptionalsControllerApiInterface {
  /**
   *
   * @summary getAmenities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApiInterface
   */
  getAmenitiesUsingGET(options?: any): AxiosPromise<Array<AmenityDTO>>;

  /**
   *
   * @summary getMaterials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApiInterface
   */
  getMaterialsUsingGET(options?: any): AxiosPromise<Array<MaterialDTO>>;

  /**
   *
   * @summary getSecurities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApiInterface
   */
  getSecuritiesUsingGET(options?: any): AxiosPromise<Array<SecurityDTO>>;

  /**
   *
   * @summary getStyles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApiInterface
   */
  getStylesUsingGET(options?: any): AxiosPromise<Array<StyleDTO>>;

  /**
   *
   * @summary getTypes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApiInterface
   */
  getTypesUsingGET(options?: any): AxiosPromise<Array<string>>;
}

/**
 * OptionalsControllerApi - object-oriented interface
 * @export
 * @class OptionalsControllerApi
 * @extends {BaseAPI}
 */
export class OptionalsControllerApi
  extends BaseAPI
  implements OptionalsControllerApiInterface
{
  /**
   *
   * @summary getAmenities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApi
   */
  public getAmenitiesUsingGET(options?: any) {
    return OptionalsControllerApiFp(this.configuration)
      .getAmenitiesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getMaterials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApi
   */
  public getMaterialsUsingGET(options?: any) {
    return OptionalsControllerApiFp(this.configuration)
      .getMaterialsUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getSecurities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApi
   */
  public getSecuritiesUsingGET(options?: any) {
    return OptionalsControllerApiFp(this.configuration)
      .getSecuritiesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getStyles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApi
   */
  public getStylesUsingGET(options?: any) {
    return OptionalsControllerApiFp(this.configuration)
      .getStylesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getTypes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OptionalsControllerApi
   */
  public getTypesUsingGET(options?: any) {
    return OptionalsControllerApiFp(this.configuration)
      .getTypesUsingGET(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyControllerApi - axios parameter creator
 * @export
 */
export const PropertyControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary createProperty
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyUsingPOST: async (
      propertyDTO: CreatePropertyDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'propertyDTO' is not null or undefined
      assertParamExists("createPropertyUsingPOST", "propertyDTO", propertyDTO);
      const localVarPath = `/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary editProperty
     * @param {string} id id
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPropertyUsingPUT: async (
      id: string,
      propertyDTO: CreatePropertyDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editPropertyUsingPUT", "id", id);
      // verify required parameter 'propertyDTO' is not null or undefined
      assertParamExists("editPropertyUsingPUT", "propertyDTO", propertyDTO);
      const localVarPath = `/property/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getProperties
     * @param {number} page page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertiesUsingGET: async (
      page: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getPropertiesUsingGET", "page", page);
      const localVarPath = `/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyControllerApi - functional programming interface
 * @export
 */
export const PropertyControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PropertyControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary createProperty
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyUsingPOST(
      propertyDTO: CreatePropertyDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyUsingPOST(
          propertyDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary editProperty
     * @param {string} id id
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPropertyUsingPUT(
      id: string,
      propertyDTO: CreatePropertyDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editPropertyUsingPUT(
          id,
          propertyDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary getProperties
     * @param {number} page page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertiesUsingGET(
      page: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PagePropertyPreviewDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertiesUsingGET(page, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PropertyControllerApi - factory interface
 * @export
 */
export const PropertyControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PropertyControllerApiFp(configuration);
  return {
    /**
     *
     * @summary createProperty
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyUsingPOST(
      propertyDTO: CreatePropertyDTO,
      options?: any
    ): AxiosPromise<PropertyDTO> {
      return localVarFp
        .createPropertyUsingPOST(propertyDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary editProperty
     * @param {string} id id
     * @param {CreatePropertyDTO} propertyDTO propertyDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPropertyUsingPUT(
      id: string,
      propertyDTO: CreatePropertyDTO,
      options?: any
    ): AxiosPromise<PropertyDTO> {
      return localVarFp
        .editPropertyUsingPUT(id, propertyDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary getProperties
     * @param {number} page page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertiesUsingGET(
      page: number,
      options?: any
    ): AxiosPromise<PagePropertyPreviewDTO> {
      return localVarFp
        .getPropertiesUsingGET(page, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PropertyControllerApi - interface
 * @export
 * @interface PropertyControllerApi
 */
export interface PropertyControllerApiInterface {
  /**
   *
   * @summary createProperty
   * @param {CreatePropertyDTO} propertyDTO propertyDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApiInterface
   */
  createPropertyUsingPOST(
    propertyDTO: CreatePropertyDTO,
    options?: any
  ): AxiosPromise<PropertyDTO>;

  /**
   *
   * @summary editProperty
   * @param {string} id id
   * @param {CreatePropertyDTO} propertyDTO propertyDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApiInterface
   */
  editPropertyUsingPUT(
    id: string,
    propertyDTO: CreatePropertyDTO,
    options?: any
  ): AxiosPromise<PropertyDTO>;

  /**
   *
   * @summary getProperties
   * @param {number} page page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApiInterface
   */
  getPropertiesUsingGET(
    page: number,
    options?: any
  ): AxiosPromise<PagePropertyPreviewDTO>;
}

/**
 * PropertyControllerApi - object-oriented interface
 * @export
 * @class PropertyControllerApi
 * @extends {BaseAPI}
 */
export class PropertyControllerApi
  extends BaseAPI
  implements PropertyControllerApiInterface
{
  /**
   *
   * @summary createProperty
   * @param {CreatePropertyDTO} propertyDTO propertyDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApi
   */
  public createPropertyUsingPOST(
    propertyDTO: CreatePropertyDTO,
    options?: any
  ) {
    return PropertyControllerApiFp(this.configuration)
      .createPropertyUsingPOST(propertyDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary editProperty
   * @param {string} id id
   * @param {CreatePropertyDTO} propertyDTO propertyDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApi
   */
  public editPropertyUsingPUT(
    id: string,
    propertyDTO: CreatePropertyDTO,
    options?: any
  ) {
    return PropertyControllerApiFp(this.configuration)
      .editPropertyUsingPUT(id, propertyDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getProperties
   * @param {number} page page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyControllerApi
   */
  public getPropertiesUsingGET(page: number, options?: any) {
    return PropertyControllerApiFp(this.configuration)
      .getPropertiesUsingGET(page, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyUserControllerApi - axios parameter creator
 * @export
 */
export const PropertyUserControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary dislikeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dislikePropertyUsingPUT: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("dislikePropertyUsingPUT", "id", id);
      const localVarPath = `/dislike/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary likeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likePropertyUsingPUT: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("likePropertyUsingPUT", "id", id);
      const localVarPath = `/like/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyUserControllerApi - functional programming interface
 * @export
 */
export const PropertyUserControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PropertyUserControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary dislikeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dislikePropertyUsingPUT(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.dislikePropertyUsingPUT(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary likeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async likePropertyUsingPUT(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.likePropertyUsingPUT(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PropertyUserControllerApi - factory interface
 * @export
 */
export const PropertyUserControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PropertyUserControllerApiFp(configuration);
  return {
    /**
     *
     * @summary dislikeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dislikePropertyUsingPUT(
      id: string,
      options?: any
    ): AxiosPromise<PropertyDTO> {
      return localVarFp
        .dislikePropertyUsingPUT(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary likeProperty
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likePropertyUsingPUT(id: string, options?: any): AxiosPromise<PropertyDTO> {
      return localVarFp
        .likePropertyUsingPUT(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PropertyUserControllerApi - interface
 * @export
 * @interface PropertyUserControllerApi
 */
export interface PropertyUserControllerApiInterface {
  /**
   *
   * @summary dislikeProperty
   * @param {string} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyUserControllerApiInterface
   */
  dislikePropertyUsingPUT(id: string, options?: any): AxiosPromise<PropertyDTO>;

  /**
   *
   * @summary likeProperty
   * @param {string} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyUserControllerApiInterface
   */
  likePropertyUsingPUT(id: string, options?: any): AxiosPromise<PropertyDTO>;
}

/**
 * PropertyUserControllerApi - object-oriented interface
 * @export
 * @class PropertyUserControllerApi
 * @extends {BaseAPI}
 */
export class PropertyUserControllerApi
  extends BaseAPI
  implements PropertyUserControllerApiInterface
{
  /**
   *
   * @summary dislikeProperty
   * @param {string} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyUserControllerApi
   */
  public dislikePropertyUsingPUT(id: string, options?: any) {
    return PropertyUserControllerApiFp(this.configuration)
      .dislikePropertyUsingPUT(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary likeProperty
   * @param {string} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyUserControllerApi
   */
  public likePropertyUsingPUT(id: string, options?: any) {
    return PropertyUserControllerApiFp(this.configuration)
      .likePropertyUsingPUT(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
